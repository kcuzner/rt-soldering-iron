#!/usr/bin/bash

FONT='0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Â°'

ARRAY16X32=""
for c in $FONT;
do
    echo "Generating $c..."
    XBM=$(convert -resize 16x32\! -font Bitstream-Vera-Sans-Mono -pointsize 24 label:${c} xbm:-)
    BYTES=$(awk -F ',' 'BEGIN { BYTES="" } { gsub(/[ \n\r]/, "", $0); for (i = 1; i <= NF; i++) { if ($i ~ /0x[0-9a-fA-F]{2}/) BYTES=BYTES " " $i; } } END { print BYTES }' <<< $XBM)
    ARRAY16x32+=$(sed -e 's/^ *//;s/ *$//;s/ /,/g' <<< $BYTES)
    ARRAY16x32+=$',\n'
done

cat > src/font.c << EOF
/**
 * RT Soldering Iron
 *
 * Kevin Cuzner
 *
 * **GENERATED FILE**
 * DO NOT MODIFY DIRECTLY
 *
 * See the fontgen script
 */

#include "font.h"

static const uint8_t font_16x32[] = {
$ARRAY16x32
};

const uint8_t *font_get_character(FontType font, char character, uint16_t *width, uint16_t *height)
{
    const uint8_t *fontarray = 0;
    *width = 0;
    *height = 0;

    switch (font)
    {
    case FONT_16x32:
        *width = 16;
        *height = 32;
        fontarray = font_16x32;
        break;
    default:
        return 0;
    };

    if (!fontarray)
        return 0;

    uint8_t bytesPerChar = (*width / 8) + ((*width % 8) ? 1 : 0);

    if (character >= '0' && character <= '9')
    {
        return &fontarray[*height * (character - '0') * bytesPerChar];
    }
    else if (character >= 'A' && character <= 'Z')
    {
        return &fontarray[*height * (10 + (character - 'A')) * bytesPerChar];
    }
    else if (character == 167)
    {
        return &fontarray[*height * 36 * bytesPerChar];
    }
    else
    {
        return 0;
    }
}

EOF

